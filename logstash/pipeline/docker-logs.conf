# Logstash Pipeline 配置
# Docker 容器日志收集管道

input {
  # 从 Docker 容器日志文件读取
  file {
    path => "/var/lib/docker/containers/*/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => json
    type => "docker"
  }

  # TCP 输入 - 用于接收应用直接发送的日志
  tcp {
    port => 5000
    codec => json_lines
    type => "tcp"
  }

  # UDP 输入 - 用于接收 syslog 格式日志
  udp {
    port => 5000
    codec => json_lines
    type => "udp"
  }

  # Beats 输入 - 用于接收 Filebeat 发送的日志
  beats {
    port => 5044
    type => "beats"
  }
}

filter {
  # Docker 日志处理
  if [type] == "docker" {
    # 解析 Docker 日志 JSON 格式
    json {
      source => "log"
      target => "docker_log"
      skip_on_invalid_json => true
    }

    # 从文件路径提取容器 ID
    grok {
      match => { 
        "path" => "/var/lib/docker/containers/%{DATA:container_id}/%{GREEDYDATA}" 
      }
    }

    # 截取容器 ID 前12位
    mutate {
      gsub => ["container_id", "(.{12}).*", "\1"]
    }

    # 解析时间戳
    date {
      match => [ "time", "ISO8601" ]
      target => "@timestamp"
    }

    # 解析日志级别
    grok {
      match => { 
        "log" => "(?<log_level>DEBUG|INFO|WARN|WARNING|ERROR|FATAL|CRITICAL)" 
      }
      tag_on_failure => []
    }

    # 设置默认日志级别
    if ![log_level] {
      mutate {
        add_field => { "log_level" => "INFO" }
      }
    }
  }

  # Nginx 日志解析
  if [stream] == "stdout" and [log] =~ /^(\d+\.\d+\.\d+\.\d+)/ {
    grok {
      match => { 
        "log" => '%{IPORHOST:client_ip} - %{DATA:user} \[%{HTTPDATE:timestamp}\] "%{WORD:method} %{DATA:request} HTTP/%{NUMBER:http_version}" %{NUMBER:response_code} %{NUMBER:bytes} "%{DATA:referrer}" "%{DATA:user_agent}"' 
      }
      tag_on_failure => ["_grokparsefailure_nginx"]
    }
  }

  # 移除不需要的字段
  mutate {
    remove_field => ["@version", "host", "path"]
  }

  # 添加处理时间戳
  ruby {
    code => "event.set('processed_at', Time.now.utc.iso8601)"
  }
}

output {
  # 输出到 Elasticsearch
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "docker-logs-%{+YYYY.MM.dd}"
    template_name => "docker-logs"
    template_overwrite => true
  }

  # 调试输出 (可选，生产环境注释掉)
  # stdout {
  #   codec => rubydebug
  # }
}
